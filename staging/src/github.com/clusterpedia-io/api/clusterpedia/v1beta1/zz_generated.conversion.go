//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by conversion-gen. DO NOT EDIT.

package v1beta1

import (
	url "net/url"

	clusterpedia "github.com/clusterpedia-io/api/clusterpedia"
	conversion "k8s.io/apimachinery/pkg/conversion"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

func init() {
	localSchemeBuilder.Register(RegisterConversions)
}

// RegisterConversions adds conversion functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterConversions(s *runtime.Scheme) error {
	if err := s.AddGeneratedConversionFunc((*url.Values)(nil), (*ListOptions)(nil), func(a, b interface{}, scope conversion.Scope) error {
		return Convert_url_Values_To_v1beta1_ListOptions(a.(*url.Values), b.(*ListOptions), scope)
	}); err != nil {
		return err
	}
	if err := s.AddConversionFunc((*clusterpedia.ListOptions)(nil), (*ListOptions)(nil), func(a, b interface{}, scope conversion.Scope) error {
		return Convert_clusterpedia_ListOptions_To_v1beta1_ListOptions(a.(*clusterpedia.ListOptions), b.(*ListOptions), scope)
	}); err != nil {
		return err
	}
	if err := s.AddConversionFunc((*url.Values)(nil), (*ListOptions)(nil), func(a, b interface{}, scope conversion.Scope) error {
		return Convert_url_Values_To_v1beta1_ListOptions(a.(*url.Values), b.(*ListOptions), scope)
	}); err != nil {
		return err
	}
	if err := s.AddConversionFunc((*ListOptions)(nil), (*clusterpedia.ListOptions)(nil), func(a, b interface{}, scope conversion.Scope) error {
		return Convert_v1beta1_ListOptions_To_clusterpedia_ListOptions(a.(*ListOptions), b.(*clusterpedia.ListOptions), scope)
	}); err != nil {
		return err
	}
	return nil
}

func autoConvert_url_Values_To_v1beta1_ListOptions(in *url.Values, out *ListOptions, s conversion.Scope) error {
	// WARNING: Field ListOptions does not have json tag, skipping.

	if values, ok := map[string][]string(*in)["names"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.Names, s); err != nil {
			return err
		}
	} else {
		out.Names = ""
	}
	if values, ok := map[string][]string(*in)["clusters"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.ClusterNames, s); err != nil {
			return err
		}
	} else {
		out.ClusterNames = ""
	}
	if values, ok := map[string][]string(*in)["namespaces"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.Namespaces, s); err != nil {
			return err
		}
	} else {
		out.Namespaces = ""
	}
	if values, ok := map[string][]string(*in)["orderby"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.OrderBy, s); err != nil {
			return err
		}
	} else {
		out.OrderBy = ""
	}
	if values, ok := map[string][]string(*in)["ownerUID"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.OwnerUID, s); err != nil {
			return err
		}
	} else {
		out.OwnerUID = ""
	}
	if values, ok := map[string][]string(*in)["ownerName"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.OwnerName, s); err != nil {
			return err
		}
	} else {
		out.OwnerName = ""
	}
	if values, ok := map[string][]string(*in)["since"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.Since, s); err != nil {
			return err
		}
	} else {
		out.Since = ""
	}
	if values, ok := map[string][]string(*in)["before"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.Before, s); err != nil {
			return err
		}
	} else {
		out.Before = ""
	}
	if values, ok := map[string][]string(*in)["ownerGR"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_string(&values, &out.OwnerGroupResource, s); err != nil {
			return err
		}
	} else {
		out.OwnerGroupResource = ""
	}
	if values, ok := map[string][]string(*in)["ownerSeniority"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_int(&values, &out.OwnerSeniority, s); err != nil {
			return err
		}
	} else {
		out.OwnerSeniority = 0
	}
	if values, ok := map[string][]string(*in)["withContinue"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_Pointer_bool(&values, &out.WithContinue, s); err != nil {
			return err
		}
	} else {
		out.WithContinue = nil
	}
	if values, ok := map[string][]string(*in)["withRemainingCount"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_Pointer_bool(&values, &out.WithRemainingCount, s); err != nil {
			return err
		}
	} else {
		out.WithRemainingCount = nil
	}
	if values, ok := map[string][]string(*in)["onlyMetadata"]; ok && len(values) > 0 {
		if err := runtime.Convert_Slice_string_To_bool(&values, &out.OnlyMetadata, s); err != nil {
			return err
		}
	} else {
		out.OnlyMetadata = false
	}
	// WARNING: Field urlQuery does not have json tag, skipping.

	return nil
}
